<!DOCTYPE html>
<html>
<head>
<title>user_manual.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>Welcome! This manual contains instructions how to use the ICCL tool. The aim of this project is to provide a process discovery tool that enhances the comprehensibility of discovered object-centric Petri nets by clustering.
The prerequisites to apply this tool are knowledge in Process Mining, object-centric Process Mining and unsupervised learning techniques such as clustering.
The main pipeline of the application works the following way:</p>
<ol>
<li>After the installation and successfull start of the server, you can open the application. By default, you start on the data import page.</li>
<li>On the import page you can upload an object-centric event log from your local machine.</li>
<li>You then run through the clustering pipeline. This includes configuring the set of selected features, the graph embedding method, the clustering method as well as additional tools such as cluster evaluation.</li>
<li>You apply process discovery and access the process models based on the clustering before. You now have a more comprehensible representation of the original process model.</li>
</ol>
<h2 id="table-of-content">Table of Content</h2>
<ol>
<li><a href="#installation">Installation</a></li>
<li><a href="#application-layout">Application Layout</a></li>
<li><a href="#data-management">Data Management</a>
<ul>
<li><a href="#import-ocel">Import OCEL</a></li>
<li><a href="#view-ocel">View OCEL</a></li>
</ul>
</li>
<li><a href="#configuration-pipeline">Configuration Pipeline</a>
<ul>
<li><a href="#feature-selection">Feature Selection</a></li>
<li><a href="#graph-embedding">Graph Embedding</a></li>
<li><a href="#clustering">Clustering</a></li>
<li><a href="#cluster-evaluation">Cluster Evaluation</a></li>
<li><a href="#process-executions">Process Executions</a></li>
</ul>
</li>
<li><a href="#process-discovery">Process Discovery</a>
<ul>
<li><a href="#discover-process-model">Discover Process Model</a>
<ul>
<li><a href="#comprehensive-process-model">Comprehensive Process Model</a></li>
<li><a href="#cluster-process-models">Cluster Process Models</a></li>
</ul>
</li>
<li><a href="#conformance-checking">Conformance Checking</a></li>
<li><a href="#export-process-model">Export Process Model</a></li>
</ul>
</li>
<li><a href="#algorithms">Algorithms</a>
<ul>
<li><a href="#process-execution-extraction">Process Execution Extraction</a></li>
<li><a href="#graph-embedding-methods">Graph Embedding Methods</a></li>
<li><a href="#clustering-techniques">Clustering Techniques</a></li>
<li><a href="#evaluation-measures">Evaluation Measures</a>
<ul>
<li><a href="#cluster-evaluation-measures">Cluster Evaluation Measures</a></li>
<li><a href="#model-evaluation-measures">Model Evaluation Measures</a></li>
</ul>
</li>
<li><a href="#model-discovery">Model Discovery</a></li>
</ul>
</li>
</ol>
<h2 id="installation">Installation</h2>
<h3 id="using-docker">Using Docker</h3>
<p>The code comes with a Dockerfile to build and run the application inside a docker container. To build the container run</p>
<pre class="hljs"><code><div>docker build -t docker-iccl . 
</div></code></pre>
<p>After the container is built, the webapp can be run using</p>
<pre class="hljs"><code><div>docker run -p 8050:8050 docker-iccl
</div></code></pre>
<p>Open <code>http://127.0.0.1:8050/</code> to access the running webapp.</p>
<h2 id="application-layout">Application Layout</h2>
<p><img src="Application_Layout_Start.png" alt="Application_Layout_Start.png">
The application layout is structured the following way:</p>
<ol>
<li>The sidebar, to navigate through the application pipeline. The sidebar is visible throughout the whole workflow. You can navigate back-and-forth using these clickable page tabs.</li>
<li>The linked help page which provides the manual for this tool. Click on the question mark to access the manual.</li>
<li>In the middle the content of the page is located. By default, you start your ICCL journey with the data import page.</li>
</ol>
<h2 id="data-management">Data Management</h2>
<h3 id="import-ocel">Import OCEL</h3>
<p><img src="import_data.png" alt="plot"></p>
<p>To import and select an OCEL, follow these steps:</p>
<ul>
<li>1a: click on the drag and drop field and select a file from the file browser</li>
<li>1b.1: click the REFRESH button to update the file list</li>
<li>1b.2: select an OCEL from the list
If you uploaded an OCEL before, the file is saved and will be available in the list 1b.2</li>
</ul>
<p>If you have selected an OCEL with .csv format, the first rows of the .csv are displayed in table 6 and you have to fill out the form 2a:</p>
<ul>
<li>2a: specify the OCEL parameters by selecting the column names in the dropdown lists. Select the object types in the last dropdown list.</li>
<li>2b: parse the parameters by clicking the PARSE CSV PARAMETERS button</li>
</ul>
<p>After selecting a file, proceed as follows:</p>
<ul>
<li>3: specify the type of process execution extraction. If leading object type is selected, the possible object types are loaded into the list. Select one of the object types.</li>
<li>4: click the UPLOAD button. Note: a progress bar will be displayed, showing you the progress of uploading the OCEL</li>
</ul>
<p>Optional:</p>
<ul>
<li>5: click the CANCEL button to stop the uploading process.</li>
</ul>
<p>After successfully uploading the OCEL, the first five rows are displayed in the table 6.</p>
<p>Note: only OCEL files with .csv, .jsonocel or .xmlocel extensions are supported.</p>
<h3 id="view-ocel">View OCEL</h3>
<p><img src="View_OCEL.png" alt="View_OCEL.png"></p>
<p>To view the statistics and gain insight into your OCEL you can visit the 'View OCEL' page.
The page can be accessed via the sidebar clicking on 'View OCEL' (1).
Inside 2 you can see the summary statistics of your OCEL, providing information such as the object types 2.a or the activity count for each activity 2.b.
The table 3 shows the entries of the OCEL, whereas the number of rows is limited to the first 1000 rows.</p>
<h2 id="configuration-pipeline">Configuration Pipeline</h2>
<p>The configuration pipeline to cluster your process executions is as follows:</p>
<ul>
<li>1: Choose the option Clustering from the sidebar</li>
<li>2: Select your features within the tab Features</li>
<li>3: Choose the graph embedding technique within the tab Embedding</li>
<li>4: Choose the clustering technique and parameters within the tab Clustering</li>
</ul>
<p>Optional:</p>
<ul>
<li>5: evaluate the clustering techniques in the Cluster Evaluation tab</li>
<li>6: visualize the process execution graphs in the Process Executions tab</li>
</ul>
<h3 id="feature-selection">Feature Selection</h3>
<p>The starting point of the pipeline is the feature selection. Each process execution is represented as a graph, and each node (=event) can carry different features.</p>
<p>We provide several possible features from different perspectives from which you can choose. Note that you don't have to choose any features at all and can choose as many features as you like.</p>
<p>However, you must click the SET SELECTED FEATURES button so that the chosen selection is parsed.</p>
<p><img src="Feature_Selection.png" alt="plot"></p>
<p>Conduct the feature selection:</p>
<ol>
<li>click on the Clustering page</li>
<li>click on the Features tab</li>
<li>list of the different features with short explanations, grouped by perspective</li>
<li>select the desired features in the dropdown lists - note: you don't have to select features for each perspective</li>
<li>click the SET SELECTED FEATURES button</li>
</ol>
<h3 id="graph-embedding">Graph Embedding</h3>
<p>The process execution graphs get enriched with features and are then embedded, so that a clustering algorithm can handle them. In the graph embedding tab, you can specify which kind of embedding technique you want to use. Please see <a href="#graph-embedding-methods">Graph Embedding Methods</a> for more information about the embedding algorithms.</p>
<p><img src="Graph_Embedding.png" alt="Graph_Embedding.png"></p>
<p>To specify the graph embedding technique, follow those steps:</p>
<ol>
<li>click on the Clustering page</li>
<li>click on the Embedding tab</li>
<li>select one of the embedding techniques</li>
<li>depending on your selection in 3, a set of adjustable parameters is displayed - you can insert custom parameter values or leave it at the default settings</li>
<li>click the PARSE EMBEDDING PARAMETERS button</li>
</ol>
<h3 id="clustering">Clustering</h3>
<p>After the graph embedding is created, you can cluster the process executions. To do so, you have to specify a clustering technique. Furthermore, you can adjust the algorithm's parameters or use the automatic clustering mode. Please see <a href="#clustering-techniques">Clustering Techniques</a> for more information about the clustering algorithms.</p>
<p><img src="Clustering_Configuration.png" alt="Clustering_Configuration.png"></p>
<p>Here's how you can execute the clustering:</p>
<ol>
<li>click on the Clustering page</li>
<li>click on the Clustering tab</li>
<li>choose a clustering technique</li>
<li>depending on your selection 3., a set of adjustable parameters is displayed - if you have chosen K-Means or Hierarchical, you can change the number of clusters by manipulating the slider</li>
<li>click the PARSE CLUSTERING PARAMETERS button</li>
<li>click the START CLUSTERING button</li>
</ol>
<p>After clicking the START CLUSTERING button, a progress bar is displayed, informing you about how far the process of clustering has progressed.
If you want to cancel the process, click the CANCEL button 7.</p>
<p>After the clustering was successfully executed, the following shows up:</p>
<p><img src="Clustering_Configuration_1.png" alt="Clustering_Configuration.png"></p>
<p>In the table 1, you can see the resulting clusters and the number of process executions that belong to the cluster ID. If you click the button 2, you get forwarded to the process discovery page.</p>
<h3 id="cluster-evaluation">Cluster Evaluation</h3>
<p>If you want to cluster the process executions using K-Means or Hierarchical Clustering, you might not know which number of clusters is suitable. On the other hand, if you apply DBscan, where you don't have to specify the number of clusters, you must specify the epsilon parameter. To give you more insight into the effect of changing those parameters, you can try the cluster evaluation analysis that is included in ICCL. You can get more information about the scores that are used in <a href="#cluster-evaluation">Cluster Evaluation</a>.</p>
<p>Note: before launching the cluster evaluation, you have to parse the features and graph embedding parameters.</p>
<p><img src="cluster_evaluation.png" alt="plot"></p>
<p>Execute the cluster evaluation:</p>
<ol>
<li>click on the Clustering page</li>
<li>click on the Cluster Evaluation tab</li>
<li>click the ANALYZE CLUSTERING TECHNIQUES button</li>
<li>look at the progress bar to see how far the process progressed</li>
<li>optional: click the CANCEL button to stop the cluster evaluation</li>
</ol>
<p>To get more information about the scores that are calculated, you can click on the arrows next to the name (6.)
After the cluster evaluation was successfully executed, you can see different plots:</p>
<ul>
<li>Hierarchical Clustering: silhouette score, Davies-Bouldin index score for average and ward linkage</li>
<li>K-Means: silhouette score and Davies-Bouldin index score</li>
<li>DBscan: silhouette score for different epsilon</li>
</ul>
<p>Look at the following plots  by way of example:
<img src="cluster_evaluation_result_1.png" alt="plot"></p>
<ol>
<li>shows the type of clustering algorithm that was used</li>
<li>result for Davies-Bouldin index for different #clusters</li>
<li>result for silhuette score for different #clusters</li>
</ol>
<p>The red dashed line indicates the best number of cluster, i.e. the number of clusters that eventuated in the optimal score.</p>
<p>The resulting plot for DBscan evaluation looks a bit different:
<img src="cluster_evaluation_result_2.png" alt="plot"></p>
<ol>
<li>indicates the optimal value for epsilon</li>
<li>shows the resulting number of clusters</li>
</ol>
<h3 id="process-executions">Process Executions</h3>
<p>One of the key aspects in ICCL is the process execution. If you want to gain more insights into the process executions of your OCEL, you can do so on the Process Executions  page.</p>
<p>Note: you can visualize the process executions and inspect its features at any point after uploading the OCEL.</p>
<p>To visualize the graph of one process execution and see its features, perform the following steps:
<img src="process_executions.png" alt="plot"></p>
<ol>
<li>click on the Clustering page</li>
<li>click on the Process Executions tab</li>
<li>click on the START PROCESS EXECUTION FEATURE EXTRACTION button</li>
<li>select a process execution in the dropdown list</li>
</ol>
<p>The results are the following:</p>
<ol start="5">
<li>feature table with the features that were extracted from the process execution</li>
<li>graph of the process execution:</li>
</ol>
<ul>
<li>to move the position of a node,  click on the node and pull it to the desired location</li>
<li>to move the whole graph, click on an edge and pull it to the desired location</li>
<li>to zoom in and out, locate the cursor on the graph and use the scroll wheel of your mouse</li>
</ul>
<p>At any point after uploading the OCEL, you can see the number of process executions in 7.</p>
<h2 id="process-discovery">Process Discovery</h2>
<h3 id="discover-process-model">Discover Process Model</h3>
<p>You can discover the Process Model for the original OCEL as well as for the sub-logs that are created by clustering the OCEL. Before discovering the latter Process Models, you have to go through the ICCL pipeline, so that clusters are already created. You can discover the comprehensive Process Model at any point after uploading the OCEL.</p>
<h4 id="comprehensive-process-model">Comprehensive Process Model</h4>
<p><img src="original_model_discovery.png" alt="plot"></p>
<p>Conducting the process discovery:</p>
<ol>
<li>click on the 'Original OCEL' page</li>
<li>click the 'START PROCESS DISCOVERY' button</li>
</ol>
<p>After the process discovery is performed, the resulting model is displayed below.
You can manipulate the view of the process model:</p>
<ul>
<li>to move the view of the model,  click on the model and pull it to the desired location</li>
<li>to zoom in and out, locate the cursor on the model and use the scroll wheel of your mouse</li>
</ul>
<h4 id="cluster-process-models">Cluster Process Models</h4>
<p><img src="cluster_model_discovery.png" alt="plot"></p>
<p>Conducting the process discovery:</p>
<ol>
<li>click on the 'Clustered OCEL' page</li>
<li>click the 'START PROCESS DISCOVERY' button</li>
<li>select the process model of a specific cluster by selecting the cluster's number in the dropdown list</li>
<li>the table displays the average feature values of the process executions that belong to the model</li>
</ol>
<p>You can manipulate the view of the process model:</p>
<ul>
<li>to move the view of the model,  click on the model and pull it to the desired location</li>
<li>to zoom in and out, locate the cursor on the model and use the scroll wheel of your mouse</li>
</ul>
<h3 id="conformance-checking">Conformance Checking</h3>
<p>To compare the process model with the OCEL, you can apply two conformance checking methods: fitness and precision. Before checking the conformance of the clustered Process Models, you have to go through the ICCL pipeline, so that clusters are already created. You can check the conformance of the comprehensive Process Model at any point after uploading the OCEL.
<img src="conformance_checking.png" alt="plot"></p>
<ol>
<li>select a measure: fitness or precision</li>
<li>click the CALCULATE button</li>
<li>result of the measure (in case of conformance checking on the clustered OCEL, a table is displayed, showing the result for each cluster)</li>
</ol>
<h3 id="export-process-model">Export Process Model</h3>
<p>After discovering a process model for the original OCEL or for the clustered sub-logs (and a cluster is selected), this segment shows up:
<img src="export_model.png" alt="plot"></p>
<p>To save the displayed process model, follow these steps:</p>
<ol>
<li>enter a name for the image</li>
<li>select the file extension: png or svg</li>
<li>click the SAVE button</li>
</ol>
<p>After clicking the button, the file will be downloaded in your browser. Additionally, the file is saved within the ICCL folder under assets/process_models/.</p>
<h2 id="algorithms">Algorithms</h2>
<p>Here you can find a short description of the algorithms that are used in ICCL.</p>
<h3 id="process-execution-extraction">Process Execution Extraction</h3>
<p>A process execution is a set of events of connected objects and resembles the case notion in traditional Process Mining. You can choose between two different types of extraction methods:</p>
<ul>
<li>
<p><strong>Connected Components</strong>: the technique uses the object graphs and extracts a process execution based on all transitively connected objects. This way, complex event logs might lead to large process executions.</p>
</li>
<li>
<p><strong>Leading Object Type</strong>: after choosing one object type as the leading type, a process execution is constructed by looking at each object of the object type. Objects that are connected to the leading object are added to the process execution unless another object of that type has a lower distance. As a result, the process executions are more limited in size.</p>
</li>
</ul>
<h3 id="graph-embedding-methods">Graph Embedding Methods</h3>
<ul>
<li>
<p><strong>Auto Embed</strong>: uses Custom Feature Graph Embeddings but optimizes the number of dimensions automatically. The method tries to reduce the number of dimensions as far as possible but ensures that there are still enough dimensions to fully express the complexity of the feature graphs. This is done by comparing the normalized embedding loss (https://doi.org/10.1038/s41467-021-23795-5) for different numbers of dimensions.
The fewer dimensions, the more efficient the clustering can be performed. The final choice of dimensions is displayed to the user.
If no features were selected, graph2vec is automatically used, since our Custom Feature Graph Embedding method requires at least one feature.</p>
</li>
<li>
<p><strong>Custom Feature Graph Embedding</strong>: especially designed for ICCL. The algorithm first creates a node embedding via FeatherNode which uses characteristic functions of node features with random walk weights to describe node neighborhoods. In the second step, the node embeddings are averaged over each dimension, resulting in a vectorized embedding of the graph. Focusses <strong>features</strong>, the structure of the process execution graphs is only implicitly considered. Check out the <a href="https://karateclub.readthedocs.io/en/latest/_modules/karateclub/node_embedding/attributed/feathernode.html">karateclub documentation</a> for more information about the FeatherNode parameters that can be configured.</p>
<p>Note: The algorithm requires that at least one feature was selected.</p>
</li>
<li>
<p><strong>Graph2Vec</strong>: first identifies subgraphs sourrounding each node in the feature graphs. By means of the Weisfeiler-Lehman’s algorithm, the subgraphs are considered as the vocabulary for a doc2vec SkipGram model. Since the graph’s structure is captured within the algorithm, feature graphs that are similar in structure will be close in the embedding space. Focusses the <strong>graph structure</strong> and additionally allows one feature per node. Check out the <a href="https://karateclub.readthedocs.io/en/latest/_modules/karateclub/graph_embedding/graph2vec.html">karateclub documentation</a> for more information about the parameters that can be configured.</p>
</li>
<li>
<p><strong>Feather-G</strong>: uses characteristic functions defined on graph vertices to describe the distribution of vertex attributes. Feather-G extracts node-level features that are pooled and then used to create a description of the feature graph. Focusses only the <strong>graph structure</strong>. Check out the <a href="https://karateclub.readthedocs.io/en/latest/_modules/karateclub/graph_embedding/feathergraph.html">karateclub documentation</a> for more information about the parameters that can be configured.</p>
</li>
</ul>
<h3 id="clustering-techniques">Clustering Techniques</h3>
<p>ICCL makes use of the sklearn.cluster module to apply different clustering algorithms to the embedding. Please refer to the <a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.cluster">sklearn.cluster documentation</a> to gather more information about the clustering parameters that can be configured in ICCL.</p>
<ul>
<li>
<p><strong>Auto Cluster</strong>: This techniques tries to find the best clustering technique automatically and optimizes their hyperparameters. Currently, we compare MeanShift, DBscan and KMeans with different parameter settings and our goal is to find a setting which maximizes the silhouette score. After the clustering has been performed, the final selected method as well as its parameters are displayed to the user.</p>
</li>
<li>
<p><strong>K-Means</strong>: clusters data by trying to separate samples in k groups of equal variance. It aims to choose centroids that minimize the within-cluster sum-of-squares. The number of clusters (k) has to be specified beforehand.</p>
</li>
<li>
<p><strong>Hierarchical Clustering</strong>: builds nested clusters by merging or splitting them successively. This hierarchy of clusters is represented as a tree, whereas the root is the unique cluster gathering all samples and the leaves are clusters containing only one sample. In ICCL, you have to specify the number of clusters beforehand.</p>
</li>
<li>
<p><strong>Mean-Shift</strong>: aims to discover blobs in a smooth density of samples. It is a centroid based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region.</p>
</li>
<li>
<p><strong>Affinity-Propagation</strong>: Affinity-Propagation creates clusters by sending messages between pairs of samples until convergence. The algorithm finds members of the data points that are representatives of the clusters.</p>
</li>
<li>
<p><strong>DBscan</strong>: Density-Based Spatial Clustering of Applications with Noise is a clustering approach that finds core samples of high density and expands clusters from them. The parameter epsilon is specifying the radius of a neighborhood with respect to some point, in which the number of neighboring points is counted.</p>
</li>
</ul>
<h3 id="evaluation-measures">Evaluation Measures</h3>
<h4 id="cluster-evaluation-measures">Cluster Evaluation Measures</h4>
<ul>
<li>
<p><strong>Silhouette Score</strong>: quantifies the space between different clusters. For each number of clusters, a clustering algorithm is performed. Afterwards, it is measured how similar the observation are to the assigned cluster and how dissimilar they are to the observation of the nearest cluster. The measure has the range [-1,+1], whereas a score near +1 indicates that the clusters are well separated and negative scores indicate that the samples might be wrongly separated. Generally, the silhouette score is calculated for each datapoint and then averaged over the whole dataspace. You can find the calculation steps here: <a href="https://en.wikipedia.org/wiki/Silhouette_(clustering)">click</a></p>
</li>
<li>
<p><strong>Davies-Bouldin Index</strong>: measure of the ratio between within-cluster distances, and between cluster distances. The score is bounded between [0, 1]. The lower the value, the tighter the clusters and the seperation between clusters. The steps of calculation can be found here: <a href="https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index">click</a></p>
</li>
</ul>
<h4 id="model-evaluation-measures">Model Evaluation Measures</h4>
<ul>
<li>
<p><strong>Fitness</strong>: measures to what extend the observed traces can be replayed by the model.</p>
</li>
<li>
<p><strong>Precision</strong>: measures the extend of behaviour that is not captured in the event log, but allowed in the model.</p>
</li>
</ul>
<h3 id="model-discovery">Model Discovery</h3>
<p>The discovery of an object-centric Petri net works as follows: for each object type, a flattened event log is created and subsequently an accepting Petri net is discovered. For the discovery part, ICCL supports the Inductive Miner. In the second step, the Petri nets are merged into one Petri net. The object types are assigned to places and the variable arcs are identified.</p>
<p><strong>Inductive Miner</strong>: the algorithm recursively performs the following steps</p>
<ul>
<li>build a directly follows graph from the log</li>
<li>find a cut and return the cut-operator and cut-partition</li>
<li>split the log into sublogs</li>
</ul>

</body>
</html>
